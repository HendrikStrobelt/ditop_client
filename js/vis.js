// Generated by CoffeeScript 1.7.1
(function() {
  var SORT_BY_CVALUE, SORT_BY_DVALUE, SORT_BY_GROUP, actualDataset, actualView, addGroupItems, allAnnotations, allClouds, bestRadius, bestRadiusScale, bestRadiusScaleInv, cloudData, configurations, createLabels, createPieBackground, decorateCloudsWithSets, decorateNewClouds, drawClouds, fill, gDragBehav, gDragDrag, getBitIndices, height, loadDataSet, maxValueMap, moveGroupItems, moveGroupItemsDiscrete, numberFormat, offsetVisX, offsetVisY, selectedSet, selectedTopicSize, serverURL, setAttributes, showTextLabels, slotSize, slotsHorizontal, sortAndUpdate, svg, topicLabelNumberMapping, updateDataSet, updateDiTop, updateWithDValue, width, zoom, zoomInstance;

  serverURL = "http://localhost:8080/ditop";

  actualDataset = "";

  configurations = {};

  selectedSet = 0;

  selectedTopicSize = 0;

  cloudData = [];

  topicLabelNumberMapping = {};

  maxValueMap = {};

  actualView = "orig";

  numberFormat = d3.format("0.2f");

  showTextLabels = true;

  setAttributes = [
    {
      sector: 0,
      name: "set2Items",
      testFor: 2,
      yOffset: 0,
      text_anchor: "start"
    }, {
      sector: 4,
      name: "set4Items",
      testFor: 4,
      yOffset: 0,
      text_anchor: "end"
    }, {
      sector: 2,
      name: "set1Items",
      testFor: 1,
      yOffset: 10,
      text_anchor: "middle"
    }
  ];

  svg = {};

  allClouds = {};

  allAnnotations = {};

  width = 1000;

  height = 1000;

  offsetVisX = 80;

  offsetVisY = 80;

  slotsHorizontal = 6;

  slotSize = 180;

  SORT_BY_GROUP = 1;

  SORT_BY_DVALUE = 2;

  SORT_BY_CVALUE = 3;

  fill = d3.scale.category10();

  gDragDrag = function(d, i) {
    d.x += d3.event.dx;
    d.y += d3.event.dy;
    return d3.select(this).attr('x', d.x).attr('y', d.y).attr("transform", "translate(" + d.x + "," + d.y + ")");
  };

  gDragBehav = d3.behavior.drag().origin(function(d) {
    return d;
  }).on("drag", gDragDrag).on("dragstart", function() {
    return d3.event.sourceEvent.stopPropagation();
  });

  zoomInstance = {};

  $("#showButton").click(function() {
    var key, topicSize;
    svg.selectAll(".arc").transition().style("opacity", 0);
    key = Object.keys(configurations)[selectedSet];
    topicSize = configurations[key][selectedTopicSize];
    console.log(key, topicSize);
    $("#workingSymbol").toggleClass("hidden");
    return loadDataSet(key + "/" + topicSize);
  });

  $("#updateDValue").click(function() {
    $("#workingSymbol").toggleClass("hidden");
    return updateWithDValue($("#dThresh").val());
  });

  $("#sortButton").click(function() {
    svg.selectAll(".arc").transition().style("opacity", 0);
    return sortAndUpdate(SORT_BY_GROUP);
  });

  $("#sortDButton").click(function() {
    svg.selectAll(".arc").transition().style("opacity", 0);
    return sortAndUpdate(SORT_BY_DVALUE);
  });

  $("#sortCButton").click(function() {
    svg.selectAll(".arc").transition().style("opacity", 0);
    return sortAndUpdate(SORT_BY_CVALUE);
  });

  $("#ditopButton").click(function() {
    return updateDiTop();
  });

  $("#resetButton").click(function() {
    console.log("res");
    zoomInstance.translate([0, 0]).scale(1);
    return svg.attr("transform", "translate(0,0) scale(1)");
  });

  $("#showTextLabels").change(function() {
    showTextLabels = $("#showTextLabels").prop("checked");
    return d3.selectAll(".labelText").transition().style({
      "opacity": function() {
        if (showTextLabels) {
          return 1;
        } else {
          return .0001;
        }
      }
    });
  });

  $("#uploadForm").attr("action", serverURL + "/upload");

  this.startVis = function() {
    var yaxis;
    zoomInstance = d3.behavior.zoom().scaleExtent([.1, 8]).on("zoom", function() {
      return zoom();
    });
    svg = d3.select("#vis").append("svg").attr("width", width).attr("height", height).call(zoomInstance).append("g");
    yaxis = d3.range(offsetVisY - slotSize / 6, height, slotSize / 3);
    svg.selectAll("line.vertical").data(yaxis).enter().append("svg:line").attr({
      "y1": function(d) {
        return d;
      },
      "x1": 0,
      "y2": function(d) {
        return d;
      },
      "x2": width
    }).style({
      "stroke": "#dddddd",
      "stroke-width": 0.5
    });
    createPieBackground();
    allClouds = svg.append("g").attr("id", "allClouds");
    allAnnotations = svg.append("g").attr("id", "allAnnotations");
    return $.ajax({
      url: serverURL + "/datasets",
      dataType: 'json',
      success: function(resData) {
        if (resData != null) {
          configurations = resData;
          updateDataSet();
        }
        return console.log(resData);
      }
    });
  };

  zoom = function() {
    return svg.attr("transform", "translate(" + d3.event.translate[0] + "," + d3.event.translate[1] + ") scale(" + d3.event.scale + ")");
  };

  updateDataSet = function() {
    var dList, elementList, keys, sList, topicSizes;
    keys = Object.keys(configurations);
    dList = d3.select("#datasetList");
    elementList = dList.selectAll("option").data(keys);
    elementList.exit().remove();
    elementList.enter().append("option").text(function(d, i) {
      return d;
    });
    dList.on("change", function() {
      selectedSet = this.selectedIndex;
      selectedTopicSize = 0;
      return updateDataSet();
    });
    topicSizes = configurations[keys[selectedSet]];
    sList = d3.select("#topicSizesList");
    sList;
    elementList = sList.selectAll("option").data(topicSizes);
    elementList.exit().remove();
    elementList.enter().append("option").text(function(d, i) {
      return d;
    });
    return sList.on("change", function() {
      return selectedTopicSize = this.selectedIndex;
    });
  };

  loadDataSet = function(datasetName) {
    actualDataset = datasetName;
    return $.ajax({
      url: serverURL + "/dataset/" + datasetName,
      dataType: 'json',
      jsonp: 'callback',
      success: function(resData) {
        var k, v, _ref;
        if (resData != null) {
          console.log(resData);
          maxValueMap = resData.maxValueMap;
          cloudData = [];
          _ref = resData.termGroups;
          for (k in _ref) {
            v = _ref[k];
            cloudData.push(v);
          }
          createLabels(resData.setNamesSorted);
          $("#workingSymbol").toggleClass("hidden");
          return sortAndUpdate(SORT_BY_DVALUE);
        }
      }
    });
  };

  updateWithDValue = function(dValue) {
    return $.ajax({
      url: serverURL + "/dataset/" + actualDataset,
      data: "discValue=" + dValue,
      dataType: 'json',
      jsonp: 'callback',
      success: function(resData) {
        var k, v, _ref;
        if (resData != null) {
          maxValueMap = resData.maxValueMap;
          cloudData = [];
          _ref = resData.termGroups;
          for (k in _ref) {
            v = _ref[k];
            cloudData.push(v);
          }
          console.log(cloudData);
          $("#workingSymbol").toggleClass("hidden");
          createLabels(resData.setNamesSorted);
          switch (actualView) {
            case "ditop":
              return updateDiTop();
            case "sortGroup":
              return sortAndUpdate(SORT_BY_GROUP);
            case "sortChar":
              return sortAndUpdate(SORT_BY_CVALUE);
            case "sortDisc":
              return sortAndUpdate(SORT_BY_DVALUE);
            default:
              return updateDiTop();
          }
        }
      }
    });
  };

  createLabels = function(labelNamesSorted) {
    var dataLabelEntries, groupLabels, itemCount, k, theButtons, v;
    groupLabels = d3.select("#groupLabels");
    groupLabels.selectAll(".colorLabel").remove();
    itemCount = 1;
    dataLabelEntries = [];
    topicLabelNumberMapping = {};
    for (k in labelNamesSorted) {
      v = labelNamesSorted[k];
      dataLabelEntries.push({
        "itemID": "set" + itemCount + "Items",
        "itemLabel": v
      });
      topicLabelNumberMapping[itemCount] = v;
      itemCount *= 2;
    }
    theButtons = groupLabels.selectAll(".colorLabel").data(dataLabelEntries).enter().append("g");
    theButtons.classed("colorLabel", true);
    theButtons.append("rect").attr({
      x: function(d, i) {
        return i * 150;
      },
      y: 5,
      rx: 5,
      ry: 5,
      width: 10,
      height: 30
    }).style({
      "fill": function(d) {
        return fill(d.itemID);
      }
    }).on({
      'mouseover': function(d) {
        return d3.selectAll("." + d.itemID + "_bgr").style({
          'stroke': fill(d.itemID),
          'opacity': 0.9
        });
      },
      'mouseout': function(d) {
        return d3.selectAll("." + d.itemID + "_bgr").style({
          'opacity': 0
        });
      }
    });
    return theButtons.append("text").text(function(d) {
      return d.itemLabel;
    }).attr({
      x: function(d, i) {
        return i * 150 + 13;
      },
      y: 5 + 20
    }).style({
      "text-anchor": "left",
      "font": "arial",
      "font-size": "10pt"
    });
  };

  updateDiTop = function() {
    var cdGroups, clouds;
    if (!(actualView === "ditop")) {
      actualView = "ditop";
      svg.selectAll(".arc").transition().duration(500).style("opacity", 1);
      svg.selectAll(".emptyRect").transition().duration(500).style("opacity", 0);
    }
    cdGroups = allClouds.selectAll(".clouds").data(cloudData, function(d) {
      return d.topicName;
    });
    cdGroups.each(function(d) {
      var actualRadius;
      d3.select(this).select(".setDecoration").remove();
      actualRadius = d3.select(this).select("circle").attr("r");
      d.recommendedRadius = bestRadiusScaleInv(actualRadius);
      return console.log(d.recommendedRadius, actualRadius, d.terms);
    });
    decorateCloudsWithSets(cdGroups.append("g").classed("setDecoration", true));
    cdGroups.exit().remove();
    cdGroups.attr("x", function(d) {
      return d.centerPos.x + 500;
    }).attr("y", function(d) {
      return d.centerPos.y + 500;
    }).transition().duration(1000).attr("transform", function(d, i) {
      return "translate(" + (d.centerPos.x + 500) + "," + (d.centerPos.y + 500) + ")";
    });
    cdGroups.each(function(d, i) {
      d.x = d.centerPos.x + 500;
      return d.y = d.centerPos.y + 500;
    });
    clouds = cdGroups.enter().append("g").classed("clouds", true);
    clouds.attr("x", function(d) {
      return d.centerPos.x + 500;
    }).attr("y", function(d) {
      return d.centerPos.y + 500;
    }).attr("transform", function(d, i) {
      return "translate(" + (d.centerPos.x + 500) + "," + (d.centerPos.y + 500) + ")";
    });
    clouds.each(function(d, i) {
      d.x = d.centerPos.x + 500;
      return d.y = d.centerPos.y + 500;
    });
    return decorateNewClouds(clouds);
  };

  sortAndUpdate = function(method) {
    var cdGroups, clouds;
    if (!(actualView.indexOf("sort", 0) === 0)) {
      svg.selectAll(".arc").transition().style("opacity", 0);
    }
    if (method === SORT_BY_GROUP) {
      cloudData.sort(function(a, b) {
        return a.inSetBitvector - b.inSetBitvector;
      });
      actualView = "sortGroup";
    } else if (method === SORT_BY_DVALUE) {
      cloudData.sort(function(a, b) {
        var aD, bD, test;
        aD = a.disValue;
        if (isNaN(aD)) {
          aD = 0;
        }
        bD = b.disValue;
        if (isNaN(bD)) {
          bD = 0;
        }
        test = bD - aD;
        if (test < 0) {
          return -1;
        }
        if (test > 0) {
          return 1;
        }
        return 0;
      });
      actualView = "sortDisc";
    } else if (method === SORT_BY_CVALUE) {
      cloudData.sort(function(a, b) {
        var test;
        test = b.characteristicValue - a.characteristicValue;
        if (test < 0) {
          return -1;
        }
        if (test > 0) {
          return 1;
        }
        return 0;
      });
      actualView = "sortChar";
    }
    cdGroups = allClouds.selectAll(".clouds").data(cloudData, function(d) {
      return d.topicName;
    });
    cdGroups.transition().duration(1000).attr("transform", function(d, i) {
      return "translate(" + (i % slotsHorizontal * slotSize + 80) + "," + ((i / slotsHorizontal >> 0) * slotSize + 80) + ")";
    });
    cdGroups.each(function(d, i) {
      d.x = i % slotsHorizontal * slotSize + 80;
      return d.y = (i / slotsHorizontal >> 0) * slotSize + 80;
    });
    cdGroups.exit().transition().remove();
    clouds = cdGroups.enter().append("g").classed("clouds", true);
    clouds.attr("transform", function(d, i) {
      return "translate(" + (i % slotsHorizontal * slotSize + 80) + "," + ((i / slotsHorizontal >> 0) * slotSize + 80) + ")";
    }).style({
      opacity: 0.0001
    });
    clouds.each(function(d, i) {
      d.x = i % slotsHorizontal * slotSize + 80;
      return d.y = (i / slotsHorizontal >> 0) * slotSize + 80;
    });
    decorateNewClouds(clouds);
    return clouds.transition().style({
      opacity: 1
    });
  };

  drawClouds = function() {
    var cdGroups, clouds;
    cloudData.sort(function(a, b) {
      var aD, bD, test;
      aD = a.disValue;
      if (isNaN(aD)) {
        aD = 0;
      }
      bD = b.disValue;
      if (isNaN(bD)) {
        bD = 0;
      }
      test = bD - aD;
      if (test < 0) {
        return -1;
      }
      if (test > 0) {
        return 1;
      }
      return 0;
    });
    actualView = "sortDisc";
    cdGroups = allClouds.selectAll(".clouds").data(cloudData, function(d) {
      return d.topicName;
    });
    cdGroups.each(function(d, i) {
      d.x = i % slotsHorizontal * slotSize + 80;
      return d.y = (i / slotsHorizontal >> 0) * slotSize + 80;
    });
    cdGroups.transition().attr("transform", function(d, i) {
      return "translate(" + (i % slotsHorizontal * slotSize + 80) + "," + ((i / slotsHorizontal >> 0) * slotSize + 80) + ")";
    });
    cdGroups.exit().transition().remove();
    clouds = cdGroups.enter().append("g").classed("clouds", true);
    clouds.attr("transform", function(d, i) {
      return "translate(" + (i % slotsHorizontal * slotSize + 80) + "," + ((i / slotsHorizontal >> 0) * slotSize + 80) + ")";
    }).style({
      opacity: 0.0001
    });
    clouds.each(function(d, i) {
      d.x = i % slotsHorizontal * slotSize + 80;
      return d.y = (i / slotsHorizontal >> 0) * slotSize + 80;
    });
    decorateNewClouds(clouds);
    return clouds.transition().style({
      opacity: 1
    });
  };

  decorateNewClouds = function(clouds) {
    var sd;
    clouds.append("circle").attr({
      cx: 0,
      cy: 0,
      r: function(d) {
        return bestRadiusScale(d.recommendedRadius);
      }
    }).style({
      'fill': '#fafafa',
      'stroke': "none",
      'opacity': function(d) {
        if (d.characteristicValue > 0) {
          return .3 + .7 * d.characteristicValue;
        } else {
          return 1;
        }
      }
    });
    clouds.selectAll("text").data(function(d) {
      return d.terms;
    }).enter().append("text").attr("x", function(d) {
      return d.xPos;
    }).attr("y", function(d) {
      return d.yPos;
    }).attr("text-anchor", "middle").style({
      "font-size": function(d) {
        return d.size * .9;
      },
      'dominant-baseline': 'middle'
    }).text(function(d) {
      return d.text;
    });
    clouds.append("text").classed({
      "labelText": true,
      "disLabelText": true
    }).attr({
      "y": function(d) {
        return -bestRadiusScale(d.recommendedRadius) - 4;
      },
      "x": 0,
      "text-anchor": "middle",
      'opacity': showTextLabels ? 1 : .001
    }).text(function(d) {
      return numberFormat(d.disValue * maxValueMap.disc);
    });
    sd = clouds.append("g").classed("setDecoration", true);
    decorateCloudsWithSets(sd);
    return clouds.call(gDragBehav);
  };

  decorateCloudsWithSets = function(clouds) {
    var clusterLabel, s, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = setAttributes.length; _i < _len; _i++) {
      s = setAttributes[_i];
      clouds.append("path").attr({
        "d": function(d) {
          var arcLength, thickness;
          thickness = 1 + d.disValue * 5 * .5;
          if (isNaN(thickness)) {
            thickness = 1;
          }
          arcLength = 1;
          return d3.svg.arc().innerRadius(bestRadiusScale(d.recommendedRadius) - thickness).outerRadius(bestRadiusScale(d.recommendedRadius) + thickness).startAngle((s.sector + 1 - arcLength) * (Math.PI / 3)).endAngle((s.sector + 1 + arcLength) * (Math.PI / 3))();
        }
      }).style({
        'fill': "#aaaaaa",
        'stroke': "#ffffff",
        'stroke-width': 1
      });
      clusterLabel = clouds.filter(function(d) {
        return (d.inSetBitvector & s.testFor) > 0;
      });
      clusterLabel.append("path").classed("clusterLabel", true).attr({
        "d": function(d) {
          var arcLength, thickness;
          thickness = 1 + d.disValue * 5 * .5;
          if (isNaN(thickness)) {
            thickness = 1;
          }
          arcLength = d.characteristicness[topicLabelNumberMapping[s.testFor]] * .5;
          if (isNaN(arcLength) || arcLength < .01) {
            arcLength = 0.02;
          }
          return d3.svg.arc().innerRadius(bestRadiusScale(d.recommendedRadius) - thickness - 2).outerRadius(bestRadiusScale(d.recommendedRadius) + thickness + 2).startAngle((s.sector + 1 - arcLength) * (Math.PI / 3)).endAngle((s.sector + 1 + arcLength) * (Math.PI / 3))();
        }
      }).style({
        'fill': fill(s.name)
      });
      clusterLabel.append("text").classed(s.name + "_textLabel", true).classed("labelText", true).attr({
        y: function(d) {
          return -Math.cos((s.sector + 1) * (Math.PI / 3)) * (bestRadiusScale(d.recommendedRadius) + 5) + s.yOffset;
        },
        x: function(d) {
          return Math.sin((s.sector + 1) * (Math.PI / 3)) * (bestRadiusScale(d.recommendedRadius) + 5);
        }
      }).style({
        "text-anchor": s.text_anchor,
        "font-weight": "bold",
        "font-size": 8,
        'fill': fill(s.name),
        'opacity': showTextLabels ? 1 : .001
      }).text(function(d) {
        var value;
        value = d.characteristicness[topicLabelNumberMapping[s.testFor]] * maxValueMap.char;
        return numberFormat(value);
      });
      _results.push(clusterLabel.append("rect").classed(s.name + "_bgr", true).attr({
        x: function(d) {
          return -bestRadiusScale(d.recommendedRadius) - 2;
        },
        y: function(d) {
          return -bestRadiusScale(d.recommendedRadius) - 2;
        },
        width: function(d) {
          return bestRadiusScale(d.recommendedRadius) * 2 + 4;
        },
        height: function(d) {
          return bestRadiusScale(d.recommendedRadius) * 2 + 4;
        }
      }).style({
        'fill': 'none',
        'stroke-width': 3,
        'opcacity': 0
      }));
    }
    return _results;
  };

  getBitIndices = function(bitmask, cData) {
    var d, i, res, _i, _len;
    res = [];
    for (i = _i = 0, _len = cData.length; _i < _len; i = ++_i) {
      d = cData[i];
      if (d.inSetBitvector & bitmask) {
        res.push({
          name: d.topicName,
          pos: i
        });
      }
    }
    return res;
  };

  moveGroupItems = function(setItems, className, offsetX, cData) {
    var allItems, bgRs, setVisItems;
    setVisItems = svg.select("." + className);
    allItems = setVisItems.selectAll(".setItem").data(setItems, function(d) {
      return d.name;
    });
    allItems.transition().attr({
      "transform": function(d) {
        return "translate(" + (cData[d.pos].centerPos.x + 500) + "," + (cData[d.pos].centerPos.y + 500) + ")";
      }
    });
    bgRs = setVisItems.selectAll(".bgR").data(setItems, function(d) {
      return d.name;
    });
    return bgRs.attr({
      x: function(d) {
        return cData[d.pos].centerPos.x + 500 - bestRadius(d.pos) - 2;
      },
      y: function(d) {
        return cData[d.pos].centerPos.y + 500 - bestRadius(d.pos) - 2;
      }
    });
  };

  moveGroupItemsDiscrete = function(setItems, className, offsetX) {
    var allItems, bgRs, setVisItems;
    setVisItems = svg.select("." + className);
    allItems = setVisItems.selectAll(".setItem").data(setItems, function(d) {
      return d.name;
    });
    allItems.transition().attr({
      "transform": function(d) {
        return "translate(" + (d.pos % slotsHorizontal * slotSize + offsetVisX) + "," + ((d.pos / slotsHorizontal >> 0) * slotSize + offsetVisY) + ")";
      }
    });
    bgRs = setVisItems.selectAll(".bgR").data(setItems, function(d) {
      return d.name;
    });
    return bgRs.attr({
      x: function(d) {
        return d.pos % slotsHorizontal * slotSize - 2 + offsetVisX - bestRadius(d.pos);
      },
      y: function(d) {
        return ((d.pos / slotsHorizontal >> 0) * slotSize) - 2 + offsetVisY - bestRadius(d.pos);
      }
    });
  };

  addGroupItems = function(setItems, className, sector, clearAll) {
    var allItems, bgRs, setVisItems;
    if (clearAll == null) {
      clearAll = false;
    }
    setVisItems = allAnnotations.select("." + className);
    if (setVisItems.empty()) {
      setVisItems = allAnnotations.append("g").classed(className, true);
    } else if (clearAll) {
      setVisItems.selectAll(".setItem").remove();
      setVisItems.selectAll(".bgR").remove();
    }
    allItems = setVisItems.selectAll(".setItem").data(setItems, function(d) {
      return d.name;
    });
    allItems.exit().remove();
    allItems.enter().append("g").classed("setItem", true).attr({
      "transform": function(d) {
        return "translate(" + (d.pos % slotsHorizontal * slotSize + offsetVisX) + "," + ((d.pos / slotsHorizontal >> 0) * slotSize + offsetVisY) + ")";
      }
    }).append("path").attr({
      "d": function(d) {
        var arcLength, thickness;
        thickness = 1 + cloudData[d.pos].disValue * 5 * .5;
        if (isNaN(thickness)) {
          thickness = 1;
        }
        arcLength = .25 * (0.5 + cloudData[d.pos].characteristicValue * 1.5);
        if (isNaN(arcLength) || arcLength < .4) {
          arcLength = 0.1;
        }
        console.log(arcLength);
        return d3.svg.arc().innerRadius(bestRadius(d.pos) - thickness - 2).outerRadius(bestRadius(d.pos) + thickness + 2).startAngle((sector + 1 - arcLength) * (Math.PI / 3)).endAngle((sector + 1 + arcLength) * (Math.PI / 3))();
      }
    }).style({
      'fill': fill(className)
    }).on({
      'mouseover': function() {
        return d3.selectAll("." + className + " .bgR").style({
          'stroke': fill(className),
          'opacity': 0.9
        });
      },
      'mouseout': function() {
        return d3.selectAll("." + className + " .bgR").style({
          'opacity': 0
        });
      }
    });
    bgRs = setVisItems.selectAll(".bgR").data(setItems, function(d) {
      return d.name;
    });
    bgRs.attr({
      x: function(d) {
        return d.pos % slotsHorizontal * slotSize - 2 + offsetVisX - bestRadius(d.pos);
      },
      y: function(d) {
        return ((d.pos / slotsHorizontal >> 0) * slotSize) - 2 + offsetVisY - bestRadius(d.pos);
      }
    });
    bgRs.exit().remove();
    return bgRs.enter().append("rect").classed("bgR", true).attr({
      x: function(d) {
        return d.pos % slotsHorizontal * slotSize - 2 + offsetVisX - bestRadius(d.pos);
      },
      y: function(d) {
        return ((d.pos / slotsHorizontal >> 0) * slotSize) - 2 + offsetVisY - bestRadius(d.pos);
      },
      width: function(d) {
        return bestRadius(d.pos) * 2 + 4;
      },
      height: function(d) {
        return bestRadius(d.pos) * 2 + 4;
      }
    }).style({
      'fill': 'none',
      'stroke-width': 3,
      'opcacity': 0
    });
  };

  bestRadius = function(pos) {
    return bestRadiusScale(cloudData[pos].recommendedRadius);
  };

  bestRadiusScale = function(r) {
    return r * .8;
  };

  bestRadiusScaleInv = function(r) {
    return r / .8;
  };

  createPieBackground = function() {
    var arc, g;
    arc = d3.svg.arc().outerRadius(1000).innerRadius(0).startAngle(function(d) {
      return d.start;
    }).endAngle((function(d) {
      return d.end;
    }));
    g = svg.selectAll(".arc").data([
      {
        iname: "set2Items",
        start: 0,
        end: 2 * Math.PI / 3.0
      }, {
        iname: "set1Items",
        end: 4 * Math.PI / 3.0,
        start: 2 * Math.PI / 3.0
      }, {
        iname: "set4Items",
        start: 4 * Math.PI / 3.0,
        end: 2 * Math.PI
      }
    ]).enter().append("g").attr("class", "arc");
    g.append("path").attr("d", arc).style("fill", function(d) {
      var color;
      color = d3.rgb(fill(d.iname)).hsl();
      color.l = .9;
      return color;
    });
    return g.attr({
      "transform": "translate(500,500)"
    }).style({
      "opacity": 0
    });
  };

}).call(this);

//# sourceMappingURL=vis.map
